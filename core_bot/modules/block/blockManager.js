var bus = require('../bus/bus.js'),
  H = require('../../utils/helper'),
  randomString = require('randomstring'),
  messageClass = require('../../utils/objects/message.js'),
  blockClass = require('../../utils/objects/block.js');

/// BLOCK MANAGER
// This module handles all blocks matters.
// There is 2 types of blocks : submitted and enchained (global.tempBlocksMap and global.blocksMap)
//      - Submitted blocks are the ones generated by each bot, from existing transactions. Each bot distributes its
//                         own generated blocks and each bot receives and validates blocks coming from other bots.
//                         Once validated, blocks are sent once again to a random group of bots, and on .. to propagate
//                         the block to every bots. A bot does not validate its own blocks, it sends the just created
//                         block to others and, this blocks may come back, to its creator after validation of other bots/
//                         If a submitted block is not valid, propagation is stopped.
//      - Enchained blocks are submitted blocks that have been chosen by an elected bot to be a part of the blockchain. To
//                         be chosen, a block must be validated.
//


function BlockManager() {
  logger.log(LOG_BLK, 'Block Manager subscribing events');
  bus.eventBus.on(CTRL_BLKMGR_NEW_BLOCK, function(block) {
    manageNewBlock(block);
  });
  bus.eventBus.on(CTRL_BLKMGR_SHARE, function(bot) {
    shareBlocks(bot);
  });
  bus.eventBus.on(CTRL_BLKMGR_UPDATE_BLOCKS, function(message) {
    updateBlocks(message);
  });
  bus.eventBus.on(CTRL_BLKMGR_CHOOSE_BLOCK, function() {
    chooseBlockToAdd();
  });
  bus.eventBus.on(CTRL_BLKMGR_CLEAN_BLOCKLIST, function() {
    cleanTmpBlockList();
  });
  bus.eventBus.on(CTRL_BLKMGR_LAUNCH, function() {
    setTimeout(function() {
      launchRandomBlock();
    }, 25 * 1000);
  });
};

// LaunchRandomBlock
// This function is launched when bot starts. It considers every available transactions and composes a new block from these.
// The block is then send and submitted to the network.
function launchRandomBlock() {
  // A block is automatically generated after a random delay (0-10 s)
  var delay = randomString.generate({
    length: 1,
    charset: 'numeric'
  })
  // Block Id is randomized to avoid duplicates and to track blocks easily
  var generationId = randomString.generate({
    length: 8,
    charset: 'alphanumeric'
  });

  logger.log(LOG_BLK, 'GENERATING BLOCK - ' + generationId);

  var threshold = global.cfg.trxPerBlock;
  // A block needs to use X transactions to be submitted
  if (global.transactionsMap.size < threshold) {
    logger.log(LOG_BLK, 'Not enough available transactions' + global.transactionsMap.size + '/' + threshold + ')');
    // Not enough transactions to created a block, restart the generation
    setTimeout(function() {
      launchRandomBlock();
    }, delay * 1000);
  } else {
    // Select randomly transactions from availables
    logger.log(LOG_BLK, 'Available trx : ' + global.transactionsMap.size);
    var transactionToBlockMap = new Map();
    var trxs = Array.from(global.transactionsMap.values());
    while (transactionToBlockMap.size < threshold) {
      var tmpTrx = trxs[Math.floor(Math.random() * trxs.length)];
      transactionToBlockMap.set(tmpTrx.id, tmpTrx);
      logger.log(LOG_BLK, 'trx selected : ' + tmpTrx.id + '    ' + 'all selected : ' + transactionToBlockMap.size);
    }

    // Create the full block Object
    var block = new blockClass();
    block.id = global.lastBlockId;
    block.content = H.mapToJson(transactionToBlockMap);
    block.creator = global.localBot.botID;
    block.generationID = generationId;
    block.randomValue = Math.random();
    timestamp = Date.now().toString();
    // Create the message to diffuse the block
    var blockMessage = new messageClass();
    blockMessage.emetter = global.localBot;
    blockMessage.channel = 'UDP';
    blockMessage.content = block;
    blockMessage.contentType = MESSAGE_NEW_BLOCK;
    logger.log(LOG_BLK, 'Broadcasting block');
    bus.eventBus.sendEvent(BLKMGR_CTRL_BROADCAST, blockMessage);

    // Automatically restart the block generation
    setTimeout(function() {
      launchRandomBlock();
    }, 30 * 1000);
  }
}
// ManageNewBlock
// A bot send a generated block to the network.
// Each receivers validate the block by ckecking if all transaction contained in are ok
// Submitted block is flagged with the last enchained block id. It permits to easily put aside blocks too old.
function manageNewBlock(block) {
  logger.log(LOG_BLK, 'New temp Block received');
  // is block id exist ? emetter is not up to date with the blockchain
  var existingBlocks = global.blocksMap.keys();
  if (global.blocksMap.get(block.blockID) != null) {
    logger.log(LOG_BLK, 'This block id already exists'); // TODO : configure text
    // TODO advise emetter to update
    return;
  }

  // is the block already received
  if (global.tempBlocksMap.get(block.generationID) != null) {
    logger.log(LOG_BLK, 'Temp Block already received and validated - current list (' + global.tempBlocksMap.size + ')');
    return;
  }

  // is block valid ?
  var trxFromBlock = H.jsonToMap(block.content);
  var blockOK = true;
  trxFromBlock.forEach(function(value, key) {
    if (blockOK) {
      if (global.transactionsMap.get(key) == null) {
        blockOK = false;
        logger.log(LOG_BLK, block.generationID + ' is trx ' + key + ' in my list ?  ---> NO'); // TODO : configure text
      } else {
        logger.log(LOG_BLK, block.generationID + ' is trx ' + key + ' in my list ?  ---> YES'); // TODO : configure text
      }
    }
  });
  if (!blockOK) {
    logger.log(LOG_BLK, 'Block is not valid');
    return;
  } else {

    // Block is valid: save the block in a temporary list
    global.tempBlocksMap.set(block.generationID, block);
    logger.log(LOG_BLK, 'Block is valid, backup it in temp list (' + global.tempBlocksMap.size + ')'); // TODO : configure text
    // diffuse validated block
    var blockMessage = new messageClass();
    blockMessage.emetter = global.localBot;
    blockMessage.channel = 'UDP';
    blockMessage.content = block;
    blockMessage.contentType = MESSAGE_NEW_BLOCK;
    bus.eventBus.sendEvent(BLKMGR_CTRL_BROADCAST, blockMessage);
  }
}

//CleanTmpBlockList
//Remove all block containing a transaction wich has been enchained with the last block
// Is it usefull ? why do not remove all blocks ? // TODO
function cleanTmpBlockList() {
  global.tempBlocksMap.forEach(function(value, key) {
    var trxsOK = true;
    var trxFromBlock = H.jsonToMap(value.content);
    // browsing all transactions from the block and check if the are in the available list. If not, block is deleted.
    trxFromBlock.forEach(function(value, key) {
      if (trxsOK) {
        logger.log(LOG_TRX, 'Cleaning blocks list.');
        if (global.transactionsMap.get(key) == null) {
          trxsOK = false;
          logger.log(LOG_TRX, 'Trx ' + key + ' unknown');
        }
      }
    });
    if (!trxsOK) {
      logger.log(LOG_BLK, 'Cleaning temp blocks list. Temp Block' + value.generationID + ' is unvalid.');
      global.tempBlocksMap.delete(value.generationID);
    }
  });
}

// ShareBlocks
// send the list of available block to bot in parameter
function shareBlocks(bot) {
  var blockMessage = new messageClass();
  blockMessage.emetter = global.localBot;
  blockMessage.channel = 'UDP';
  blockMessage.content = H.mapToJson(global.blocksMap);
  blockMessage.contentType = MESSAGE_UDPATE_BLK;
  logger.log(LOG_BLK, 'Sharing ' + global.blocksMap.size + ' blocks with bot' + bot.botID); // TODO : configure text
  blockMessage.receiver = bot;
  bus.eventBus.sendEvent(BLKMGR_CTRL_SEND_MESSAGE, blockMessage);
}

// ChooseBlockToAdd
// In case of election, local bot has to chose a block.
// this function select randomly a block by the available blocks list.
// The selected block is then validated
function chooseBlockToAdd() {
  var choosenBlock = null;
  var blockOK = false;
  logger.log(LOG_BLK, ' Choose a block (by  ' + global.tempBlocksMap.size + ' )');

  while (!blockOK && global.tempBlocksMap.size > 0) {
    // select randomly the block
    var values = Array.from(global.tempBlocksMap.values());
    choosenBlock = values[Math.floor(Math.random() * values.length)];
    var trxsOK = true;
    // is block valid ?
    var trxFromBlock = H.jsonToMap(choosenBlock.content);
    // check transactions contained in the block
    logger.log(LOG_BLK, 'Block selected. Checking transactions');
    trxFromBlock.forEach(function(value, key) {
      if (trxsOK) {
        if (global.transactionsMap.get(key) == null) {
          trxsOK = false;
          logger.log(LOG_TRX, 'Trx ' + key + ' unknown');
        }
      }
    });
    if (!trxsOK) {
      // At least one transaction is not OK; block is not valid
      blockOK = false;
      logger.log(LOG_BLK, ' Choosen temp block ' + choosenBlock.generationID + ' is unvalid. Pick another one');
      global.tempBlocksMap.delete(choosenBlock.generationID);
    } else {
      console.log("Fin inspection block ok");
      // All transactions are ok, block is valid
      logger.log(LOG_BLK, 'Choosen temp block ' + choosenBlock.generationID + ' is valid');
      blockOK = true;
      // Build the block message
      var blockMessage = new messageClass();
      blockMessage.emetter = global.localBot;
      blockMessage.channel = 'UDP';
      blockMessage.content = {
        block: choosenBlock,
        electedBot: global.localBot
      };
      blockMessage.contentType = MESSAGE_CHOSEN_BLOCK;
      // send block to the network
      global.assembly.forEach(function(value, key) {
        logger.log(LOG_BLK, 'Sending Block to elector map'); // TODO : configure text
        blockMessage.receiver = value;
        bus.eventBus.sendEvent(CTRL_SECMGR_SIGN_TO_SEND_MESSAGE, blockMessage);
      });
    }
  }
  if (!blockOK) {
    //no block has been selected and list is empty, retry in few seconds
    //TODO integrate the relaunch to assembly and select writer process to not waste time
    logger.log(LOG_BLK, 'No block available. Trying again in 15 seconds ');
    setTimeout(function() {
      chooseBlockToAdd();
    }, 15 * 1000);

  }
}

// UpdateBlocks
// Local bot is not up to date with the list of submitted block
// Another bot just sent a message containing its own list
function updateBlocks(message) {
  var newBlksMap = H.jsonToMap(message.content);
  var lastBlockId = 0;
  logger.log(LOG_BLK, 'Received ' + newBlksMap.size + ' blocks from bot ' + message.emetter.botID);
  newBlksMap.forEach(function(value, key) {
    global.tempBlocksMap.set(key, value);
    if (lastBlockId < value.blockID) {
      global.lastBlockId = value.blockID;
    }
  });
  logger.log(LOG_BLK, 'Blocks Updated');
}

module.exports = BlockManager;
